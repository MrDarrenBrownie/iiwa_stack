#! /usr/bin/python3

import rospy
from iiwa_msgs.msg import JointPosition
from iiwa_msgs.msg import CartesianPose
from iiwa_tesla_msgs.msg import SignalReceived
from iiwa_tesla_msgs.srv import Signal
from iiwa_tesla_msgs.srv import NewGoal
import math

class movement:

    def __init__(self):
        rospy.init_node('publish_movement', anonymous=True)
        self.publisher = rospy.Publisher('/iiwa/command/JointPosition', JointPosition, queue_size=1)
        self.pose_subscriber = rospy.Subscriber('iiwa/JointPosition', JointPosition, self.pose_callback)
        self.cartesian_subscriber = rospy.Subscriber('iiwa/CartesianPose', CartesianPose, self.dist_to_goal)
        print('publisher and subscriber initialized')
        rospy.spin()

        # service to get a new goal
        rospy.wait_for_service('NewGoal')
        self.demand_new_goal = rospy.ServiceProxy('NewGoal', NewGoal)
        print('service initialized')

        # TODO write service or subscriber for "INTERRUPT" command

        # TODO after "INTERRUPT" call service that performs detail motion

        self.rate = rospy.Rate(50)

        self.pose = JointPosition()
        self.cartesian = CartesianPose()

        self.home_pose = JointPosition()
        self.home_pose.position.a1 = 0.0
        self.home_pose.position.a2 = 0.0
        self.home_pose.position.a3 = 0.0
        self.home_pose.position.a4 = 0.0
        self.home_pose.position.a5 = 0.0
        self.home_pose.position.a6 = 0.0
        self.home_pose.position.a7 = 0.0

        # cartesian Positions used for distance calculation
        self.current_cartesian = CartesianPose().poseStamped.pose.position
        self.goal_cartesian = CartesianPose().poseStamped.pose.position

        # current pose and goal pose in Joint position
        self.current_pose = JointPosition()
        self.goal_pose = JointPosition()

        # default goal_pose = home_pose
        self.goal_pose = self.home_pose

        # n_goals used in request to get the next item in position list
        self.n_goal = 0

        self.threshold = 0.1

        # end initialization process with running in idle mode
        self.idle()

    def dist_to_goal(self):
        print('calc dist to goal')
        return math.sqrt(
            (self.current_cartesian.x - self.goal_cartesian.x)**2
            + (self.current_cartesian.y - self.goal_cartesian.y)**2
            + (self.current_cartesian.z - self.goal_cartesian.z)**2)


    def get_new_goal(self):
        try:
            print('try get new goal')
            self.goal_pose = self.demand_new_goal(self.n_goal)
            self.n_goal += 1
        except rospy.ServiceException as e:
            print('Service failed: %s'%e)
        # does subscriber wait until callback is finished?


    def pose_callback(self, joint_pose):
        self.current_pose = joint_pose
        print('new pose callback')
        if self.dist_to_goal() < self.threshold:
            print('dist to goal < threshold -> get new goal')
            self.get_new_goal()
        else:
            pass
        

    def signal_received(self, data):
        # if signal is received, then 
        # get the location, where the signal was received
        # stop ongoing movement
        # store the curent position
        # start hi-res scan routine at signal_received location
        return True


    def wait_for_subscribers(self):
        if self.publisher.get_num_connections() < 1:
            print('no subscribers')
            while self.publisher.get_num_connections() < 1:
                pass


    def idle(self):
        print('idle')
        while not rospy.get_param('/tesla/routine/routine_running'):
            pass
        # after param routine running is "true", continue with move()
        self.move()


    def move(self):
        print('start move')       
        while not rospy.is_shutdown():
            self.wait_for_subscribers()

            print('start moving')
            new_pose = self.goal_pose
            self.publisher.publish(new_pose)

            self.rate.sleep()


if __name__ == '__main__':
    try:
        new_movement = movement()
        print('movement routine launched')

    except rospy.ROSInterruptException:
        pass
